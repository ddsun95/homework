\documentclass[11pt]{article}
\usepackage{fullpage,amsthm,amsfonts,amssymb,epsfig,amsmath,soul}

\begin{document}
	\begin{flushleft}
		David Sun\newline
		CMPS 102\newline
		Homework 1\newline

		\item \textbf {\underline{Problem 1:}} 
		In a binary tree all nodes are either internal or they are leaves.  In our definition, internal
		nodes always have two children and leaves have zero children.  Prove that for such trees, the
		number of leaves is always one more than the number of internal nodes.\newline
		
		\textbf{Proof:}\newline
		If \emph{T} is a tree containing \emph{n} internal nodes, then \emph{T} contains \emph{n} + 1 leaves\newline\newline
		\textbf{I. Base Case}\newline
		If \emph{T} has just one internal node, then \emph{T} has two leaves, thus the number of leaves in \emph{T} is one greater than the number of internal nodes in \emph{T}.\newline\newline
		\textbf{II. Induction Step}\newline
		Let \emph{n} $\geq 1$. Assume that all trees containing \emph{n} internal nodes contain \emph{n} + 1 leaves. Generate another internal node on \emph{T} by taking an arbitrary leaf node in \emph{T} and attaching two leaf nodes to it. By generating another internal node, \emph{T} now contains \emph{n} + 1 internal nodes. In the process of generating a new internal node, one leaf node is eliminated from \emph{T} and two leaf nodes are attached to \emph{T}, so \emph{T} now contains ((\emph{n} + 1) - 1) + 2 leaf nodes. By the induction hypothesis, a tree containing \emph{n} + 1 internal nodes contains (\emph{n} + 1) + 1 leaves. \newline Thus, ((\emph{n} + 1) - 1) + 2 = (\emph{n} + 1) + 1 as required. 
		\vspace{.2cm}
		
		\item \textbf {\underline{Problem 2:}}
		For $n\ge0$ consider $2^n \times 2^n$ matrices of 1s and 0s in
		which all elements are 1, except one 
		which is 0 (The 0 is at an arbitrary position). 
		Operation: At each step, we can replace three 1s forming an
		"L" with three 0s (The L's can have an arbitrary orientation).\newline
		
		\textbf{Proof:}\newline
		If M is a $2^n \times 2^n$ matrix consisting of all 1s and one 0, there exists a sequence of "L" operations such that replacing three 1s in an "L" pattern in M will give us the 0 matrix. \newline
		
		\textbf{I. Base Case}\newline
		\emph{n} = 0. A $2^0 \times 2^0$ matrix is a 1 $\times$ 1 matrix. The only entry can be a 0, and thus applying the "L" operation 0 times is sufficient to obtain the 0 matrix.\newline 
		
		\textbf{II. Induction Step}\newline
		Let $n \ge 0$. Let M be a $2^n \times 2^n$ matrix where \emph{M} contains exactly one 0 and the rest 1s. Assume there exists a sequence of "L" operations to obtain a 0 matrix for \emph{M}. Let \emph{M'} be a $2^{n + 1} \times 2^{n + 1}$ matrix containing exactly one 0 entry with 1s for the rest of the entries.\newline 
		\emph{(continued on the next page.)}
		\newpage
		Since \emph{M'} is a $2^{n + 1} \times 2^{n + 1}$ matrix, \emph{M'} can be evenly divided into four quadrants with each quadrant containing $2^n \times 2^n$ matrix entries. This means that the initial 0 entry in \emph{M'} must lie within one of the four quadrants.
		\[
		\emph{M'} = 
		\begin{bmatrix}
			0      & \dots  & 1      & 1      & \dots  & 1      \\
			\vdots & \ddots & \vdots & \vdots & \ddots & \vdots \\
			1      & \dots  & 1      & 1      & \dots  & 1      \\     
			1      & \dots  & 1      & 1      & \dots  & 1      \\
			\vdots & \ddots & \vdots & \vdots & \ddots & \vdots \\
			1      & \dots  & 1      & 1      & \dots  & 1      \\   
		\end{bmatrix}
		\]
		In the center of \emph{M'} all of the four quadrants are adjacent to each other. In the center of \emph{M'} an "L" operation can be applied to eliminate three 1s in the three quadrants not containing the initial 0.
		\[
		\begin{bmatrix}
			0      & \dots  & 1      & 1      & \dots  & 1      \\
			\vdots & \ddots & \vdots & \vdots & \ddots & \vdots \\
			1      & \dots  & 1      & 1	  & \dots  & 1      \\     
			1      & \dots  & 1      & 1      & \dots  & 1      \\
			\vdots & \ddots & \vdots & \vdots & \ddots & \vdots \\
			1      & \dots  & 1      & 1      & \dots  & 1      \\   
		\end{bmatrix}
		\rightarrow
		\begin{bmatrix}
			0      & \dots  & 1      & 1      & \dots  & 1      \\
			\vdots & \ddots & \vdots & \vdots & \ddots & \vdots \\
			1      & \dots  & 1      & 0 	  & \dots  & 1      \\     
			1      & \dots  & 0      & 0      & \dots  & 1      \\
			\vdots & \ddots & \vdots & \vdots & \ddots & \vdots \\
			1      & \dots  & 1      & 1      & \dots  & 1      \\   
		\end{bmatrix}
		\]
		By applying the "L" operation in the center of \emph{M'}, we obtain four quadrants each containing $2^n \times 2^n$ entries with one zero entry per quadrant. By the induction hypothesis, it is possible to transform each of the four $2^n \times 2^n$ quadrants to all 0s by a sequence of "L" operations, thus a $2^{n + 1} \times 2^{n + 1}$ containing one 0 entry and 1s for the other entries can be transformed into the 0 matrix. 
		\vspace{0.2cm}
		\item \textbf {\underline{Problem 3:}}  Suppose you are given an array $A$ of $n$ distinct
		integers with the following property:
		There exists a unique index $p$ such that the values of
		$A[1\ldots p]$ are decreasing and the values of $A[p \ldots
		n]$ are increasing.\newline\newline
		\textbf{Algorithm:}
		Our divide and conquer algorithm will be called findIndex(A, low, high). Suppose A has length N, then we will initially call the function in the manner findIndex(A, 1, N). If A has length 1, we return 1 as the index. Otherwise, we compute the midpoint of the low index and the high index such that $mid$ = $\left\lfloor\dfrac{low + high}{2}\right\rfloor$. \newline
		If $mid > 1$ and  $mid < N$, check if $A[mid - 1]$ \textgreater $A[mid]$ \textless $A[mid + 1]$. If such is the case, return mid since we have found the correct index. If that condition does not hold, check if \newline A[mid - 1] \textgreater{ A[mid]} 
		\textgreater{ A[mid + 1]}. If such is the case, then p lies within $A[mid + 1 \dots N]$ So we will recur to the right of the array by calling \textbf{findIndex}$(A, mid + 1, high)$.
		However, if instead A[mid - 1] \textless{ A[mid]} \textless { A[mid + 1]} then \emph{p} lies in the left half of \emph{A}, so we will recur to the left of the array by calling
		\textbf{findIndex$(A, low, mid -1)$}.\newpage
		Edge cases in which $mid = 1$ or $mid = N$ must also be considered.\newline
		In the case that $mid = 1$, check if $A[mid] < A[mid + 1]$, if such is the case, then $p = 1$ so return $mid$. Otherwise recur to the right by calling \textbf{findIndex}$(A, mid + 1, high)$\newline
		In the case that $mid = N$, check if $A[mid] < A[mid - 1]$, if such is the case, then $p = N$ so return $mid$. Otherwise, recur to the left by calling \textbf{findIndex}$(A, low, mid - 1)$\newline
		  
		\textbf{Proof of Correctness:} The invariant that all elements from $A[1 \dots p]$ are decreasing and all elements from $A[p \dots N]$ are increasing suggests that $p$ must either lie within $A[1 \dots \left\lfloor\frac{N}{2}\right\rfloor]$ or 
		$A[\left\lfloor\frac{N}{2}\right\rfloor + 1 \dots N]$. \newline
		If the middle element satisfies the condition for $p$, then we're done.
		If the middle element is within a decreasing pattern, $p$ lies within the right subarray.  
		If the middle element is within an increasing pattern \emph{(5, 4, 3,...)}, $p$ lies within the left subarray
		In any case, our algorithm converges to a $p$ index by checking the conditions of the middle element and deciding whether to return the index of the middle element or to recur on the the left subarray or the right subarray. \newline
		\vspace{0.2cm}
		
		\textbf{Proof of Runtime:} By recurring either to left subarray or to the right subarray, the algorithm essentially discards half the input size each time. There are also a few array element comparisons, but those are done in constant time. The recurrence can be written as $T(n) = T(n / 2) + O(1)$. Using Master's theorem, we can show that $T(n)$ = $O$(log $n$).
		\vspace{0.2cm}
		
		\item \textbf {\underline{Problem 4:}} Consider a complete binary tree $T$ with $n$ nodes ($n = 2^d-1$ for some $d$). Each node $v$ of $T$ is labeled with a distinct real number $x_v$. Define a node $v$ of $T$ to be a \textit{local minimum} if the label $x_v$ is less than the label $x_w$ for all nodes $w$ that are joined to $v$ by an edge. You are given such a complete binary tree $T$, but the labeling is only specified in the following implicit way: for each node $v$, you can determine the value $x_v$ by probing the node $v$. Show how to find a local minimum of $T$ using only $O(\log n)$ probes to the nodes of $T$.\newline
		
		\textbf{Algorithm:}
		
	\end{flushleft}
\end{document}