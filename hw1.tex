\documentclass[11pt]{article}
\usepackage{fullpage,amsthm,amsfonts,amssymb,epsfig,amsmath,soul}

\begin{document}
	\begin{flushleft}
		David Sun\newline
		CMPS 102\newline
		Homework 1\newline

		\item \textbf {\underline{Problem 1:}} 
		In a binary tree all nodes are either internal or they are leaves.  In our definition, internal
		nodes always have two children and leaves have zero children.  Prove that for such trees, the
		number of leaves is always one more than the number of internal nodes.\newline
		
		\textbf{Proof:}\newline
		If \emph{T} is a tree containing \emph{n} internal nodes, then \emph{T} contains \emph{n} + 1 leaves\newline\newline
		\textbf{I. Base Case}\newline
		If \emph{T} has just one internal node, then \emph{T} has two leaves, thus the number of leaves in \emph{T} is one greater than the number of internal nodes in \emph{T}.\newline\newline
		\textbf{II. Induction Step}\newline
		Let \emph{n} $\geq 1$. Assume that all trees containing \emph{n} internal nodes contain \emph{n} + 1 leaves. Generate another internal node on \emph{T} by taking an arbitrary leaf node in \emph{T} and attaching two leaf nodes to it. By generating another internal node, \emph{T} now contains \emph{n} + 1 internal nodes. In the process of generating a new internal node, one leaf node is eliminated from \emph{T} and two leaf nodes are attached to \emph{T}, so \emph{T} now contains ((\emph{n} + 1) - 1) + 2 leaf nodes. By the induction hypothesis, a tree containing \emph{n} + 1 internal nodes contains (\emph{n} + 1) + 1 leaves. \newline Thus, ((\emph{n} + 1) - 1) + 2 = (\emph{n} + 1) + 1 as required. 
		\vspace{.2cm}
		
		\item \textbf {\underline{Problem 2:}}
		For $n\ge0$ consider $2^n \times 2^n$ matrices of 1s and 0s in
		which all elements are 1, except one 
		which is 0 (The 0 is at an arbitrary position). 
		Operation: At each step, we can replace three 1s forming an
		"L" with three 0s (The L's can have an arbitrary orientation).\newline
		
		\textbf{Proof:}\newline
		If M is a $2^n \times 2^n$ matrix consisting of all 1s and one 0, there exists a sequence of "L" operations such that replacing three 1s in an "L" pattern in M will give us the 0 matrix. \newline
		
		\textbf{I. Base Case}\newline
		\emph{n} = 0. A $2^0 \times 2^0$ matrix is a 1 $\times$ 1 matrix. The only entry can be a 0, and thus applying the "L" operation 0 times is sufficient to obtain the 0 matrix.\newline 
		
		\textbf{II. Induction Step}\newline
		Let $n \ge 0$. Let M be a $2^n \times 2^n$ matrix where \emph{M} contains exactly one 0 and the rest 1s. Assume there exists a sequence of "L" operations to obtain a 0 matrix for \emph{M}. Let \emph{M'} be a $2^{n + 1} \times 2^{n + 1}$ matrix containing exactly one 0 entry with 1s for the rest of the entries.\newline 
		\emph{(continued on the next page.)}
		\newpage
		Since \emph{M'} is a $2^{n + 1} \times 2^{n + 1}$ matrix, \emph{M'} can be evenly divided into four quadrants with each quadrant containing $2^n \times 2^n$ matrix entries. This means that the initial 0 entry in \emph{M'} must lie within one of the four quadrants.
		\[
		\emph{M'} = 
		\begin{bmatrix}
			0      & \dots  & 1      & 1      & \dots  & 1      \\
			\vdots & \ddots & \vdots & \vdots & \ddots & \vdots \\
			1      & \dots  & 1      & 1      & \dots  & 1      \\     
			1      & \dots  & 1      & 1      & \dots  & 1      \\
			\vdots & \ddots & \vdots & \vdots & \ddots & \vdots \\
			1      & \dots  & 1      & 1      & \dots  & 1      \\   
		\end{bmatrix}
		\]
		In the center of \emph{M'} all of the four quadrants are adjacent to each other. In the center of \emph{M'} an "L" operation can be applied to eliminate three 1s in the three quadrants not containing the initial 0.
		\[
		\begin{bmatrix}
			0      & \dots  & 1      & 1      & \dots  & 1      \\
			\vdots & \ddots & \vdots & \vdots & \ddots & \vdots \\
			1      & \dots  & 1      & 1	  & \dots  & 1      \\     
			1      & \dots  & 1      & 1      & \dots  & 1      \\
			\vdots & \ddots & \vdots & \vdots & \ddots & \vdots \\
			1      & \dots  & 1      & 1      & \dots  & 1      \\   
		\end{bmatrix}
		\rightarrow
		\begin{bmatrix}
			0      & \dots  & 1      & 1      & \dots  & 1      \\
			\vdots & \ddots & \vdots & \vdots & \ddots & \vdots \\
			1      & \dots  & 1      & 0 	  & \dots  & 1      \\     
			1      & \dots  & 0      & 0      & \dots  & 1      \\
			\vdots & \ddots & \vdots & \vdots & \ddots & \vdots \\
			1      & \dots  & 1      & 1      & \dots  & 1      \\   
		\end{bmatrix}
		\]
		By applying the "L" operation in the center of \emph{M'}, we obtain four quadrants each containing $2^n \times 2^n$ entries with one zero entry per quadrant. By the induction hypothesis, it is possible to transform each of the four $2^n \times 2^n$ quadrants to all 0s by a sequence of "L" operations, thus a $2^{n + 1} \times 2^{n + 1}$ containing one 0 entry and 1s for the other entries can be transformed into the 0 matrix. 
		\vspace{0.2cm}
		\item \textbf {\underline{Problem 3:}}  Suppose you are given an array $A$ of $n$ distinct
		integers with the following property:
		There exists a unique index $p$ such that the values of
		$A[1\ldots p]$ are decreasing and the values of $A[p \ldots
		n]$ are increasing.\newline\newline
		\textbf{Algorithm:}
		Our divide and conquer algorithm will be called \textbf{findIndex}(A, low, high). Suppose A has length N, then we will initially call the function in the manner \textbf{findIndex}(A, 1, N). If A has length 1, we return 1 as the index. Otherwise, we compute the midpoint of the low index and the high index such that $mid$ = $\left\lfloor\dfrac{low + high}{2}\right\rfloor$. \newline
		If $mid > 1$ and  $mid < N$, check if $A[mid - 1]$ \textgreater $A[mid]$ \textless $A[mid + 1]$. If such is the case, return $mid$ since we have found the correct index. If that condition does not hold, check if \newline $A[mid - 1]$ \textgreater{ $A[mid]$} 
		\textgreater{ $A[mid + 1]$}. If such is the case, then p lies within $A[mid + 1 \dots N]$ So we will recur to the right of the array by calling \textbf{findIndex}$(A, mid + 1, high)$.
		However, if instead $A[mid - 1]$ \textless{ $A[mid]$} \textless { $A[mid + 1]$} then \emph{p} lies within $A[1 \dots mid - 1]$, so we will recur to the left of the array by calling
		\textbf{findIndex$(A, low, mid -1)$}.\newpage
		Edge cases in which $mid = 1$ or $mid = N$ must also be considered.\newline
		In the case that $mid = 1$, check if $A[mid] < A[mid + 1]$, if such is the case, then $p = 1$ so return $mid$. Otherwise recur to the right by calling \textbf{findIndex}$(A, mid + 1, high)$\newline
		In the case that $mid = N$, check if $A[mid] < A[mid - 1]$, if such is the case, then $p = N$ so return $mid$. Otherwise, recur to the left by calling \textbf{findIndex}$(A, low, mid - 1)$\newline
		  
		\textbf{Proof of Correctness:} The invariant that all elements from $A[1 \dots p]$ are decreasing and all elements from $A[p \dots N]$ are increasing suggests that $p$ must either lie within $A[1 \dots \left\lfloor\frac{N}{2}\right\rfloor]$ or 
		$A[\left\lfloor\frac{N}{2}\right\rfloor + 1 \dots N]$. \newline
		If the middle element satisfies the condition for $p$, then we're done.
		If the middle element is within a decreasing pattern \emph{e.g. (...,5,4,3,...)}, $p$ must lie within the right subarray.  
		If the middle element is within an increasing pattern \emph{e.g. (...,3,4,5,...)}, $p$ must lie within the left subarray.
		In any case, our algorithm converges to the $p$ index by checking the conditions of the middle element and deciding whether to return the index of the middle element or to recur on the the left subarray or the right subarray. \newline
		\vspace{0.2cm}
		
		\textbf{Proof of Runtime:} If $N$ is the input size, recurring either to left subarray or to the right subarray, halves the input size. There are array element comparison which are done in constant $O(1)$ time. The recurrence can be written as $T(n) = T(n / 2) + O(1)$. Using the master theorem, we can show that $T(n)$ = $O$(log $n$).
		\vspace{0.2cm}
		
		\item \textbf {\underline{Problem 4:}} Consider a complete binary tree $T$ with $n$ nodes ($n = 2^d-1$ for some $d$). Each node $v$ of $T$ is labeled with a distinct real number $x_v$. Define a node $v$ of $T$ to be a \textit{local minimum} if the label $x_v$ is less than the label $x_w$ for all nodes $w$ that are joined to $v$ by an edge. You are given such a complete binary tree $T$, but the labeling is only specified in the following implicit way: for each node $v$, you can determine the value $x_v$ by probing the node $v$. Show how to find a local minimum of $T$ using only $O(\log n)$ probes to the nodes of $T$.\newline
		
		\textbf{Algorithm:} Start at the root of $T$. We'll call that node $v$ and its label $x_v$. If the left child of $v$ is not $NIL$ and $x_v$ is greater than the label of $v's$ left child, recur on the left subtree with the left child of $v$ as the root. Otherwise, if the right child of $v$ is not $NIL$ and $x_v$ is greater than the label of $v's$ right child, recur on the right subtree with the right child of $v$ as the root. If both of these comparisons do not hold, then $v$ must be a local minimum and therefore we return $x_v$. 
		\newline
		
		\textbf{Proof of Correctness:} By definition, a local minimum is a node in which its label is less than that of the node's connected to it by an edge. This means that either the root is a local minimum, or the local minimum is within the left subtree or the right subtree. Our algorithm searches a node's left child and right child for a lower valued label. If such a node $x_w$ exists, then the current node is not a local minimum and the algorithm recurs on the subtree with $x_w$ as the root.\newline However, if a node is a leaf, or its two children have label values greater than itself, then the node must be a minimum.
		\newpage
		
		\textbf{Proof of Runtime:} If $N$ is the input size, recurring on the left or the right discards $\left\lceil\frac{N}{2}\right\rceil$ elements, meaning that $\left\lfloor\frac{N}{2}\right\rfloor$ elements remain. There are also steps in the algorithm to compare the labels of the nodes, which take constant $O(1)$ time. The recurrence can be summarized as $T(N) = T(\left\lfloor\frac{N}{2}\right\rfloor) + O(1)$. Using the master theorem, we can show that $T(n)$ = $O$(log $n$).
		\vspace{0.2cm}
		
		\item \textbf {\underline{Problem 5:}} Show that for any non-negative integers $a,b$,
		$(n+a)^b = \Theta(n^b).$\newline
		We need to show that $(n+a)^b$ is both $O(n^b)$ as well as $\Omega(n^b)$
		
		\textbf{\underline{Proof}}\newline
		\textbf{Case 1: $(n+a)^b$ = $O(n^b)$}. \newline
		If $f(n) = O(g(n))$, then $\exists c > 0$ $\exists n_0 > 0$ such that 
		$0 \leq f(n) \leq c \cdot g(n)$. Then $\dots$
		
		\begin{center}
		\centering{$\exists c > 0$ $\exists n_0 > 0$ such that 
		$0 \leq (n+a)^b \leq c \cdot n^b$.}
		\centering{\flushleft{$(n+a)^b \leq c \cdot n^b$}}
		\centering{\flushleft{$n+a \leq c^{1/b} \cdot n$}}
		\centering{\flushleft{$a \leq c^{1/b} \cdot n - n$}}
		\centering{\flushleft{$a \leq n (c^{1/b} - 1)$}}
		\centering{\flushleft{Let $c^{1/b} = 2$, therefore $c = 2^b$}}
		\centering{\flushleft{$a \leq n (2 - 1)$}}
		\centering{\flushleft{$a \leq n$}} 
		\end{center}

		Thus if we choose $c = 2^b$ and $n_0 = a$, we can show that $0 \leq (n+a)^b \leq c \cdot n^b$ \newline thus $(n+a)^b$ = $O(n^b)$.
		\newline\newline
		\textbf{Case 2: $(n+a)^b$ = $\Omega(n^b)$}. \newline
		If $f(n) = \Omega(g(n))$, then $\exists c > 0$ $\exists n_0 > 0$ such that 
		$0 \leq c \cdot g(n) \leq f(n)$. Then $\dots$
		\begin{center}
		\centering{$\exists c > 0$ $\exists n_0 > 0$ such that 
			$0 \leq c \cdot n^b \leq (n + a)^b$.}
		\centering{\flushleft{$c \cdot n^b \leq (n+a)^b$}}
		\centering{\flushleft{$c^{1/b} \cdot n \leq n+a$}}
		\centering{\flushleft{$-a \leq n - c^{1/b} \cdot n$}}
		\centering{\flushleft{$-a \leq n(1 - c^{1/b})$}}
		\centering{\flushleft{Let $c^{1/b} = 1$, therefore $c = 1$, thus}}
		\centering{\flushleft{$-a \leq 0$}}
		\end{center}
		In this case, $c = 1$, and we can pick any arbitrary $n_0 > 0$, so choose $n_0 = a$. Using these values for $c$ and $n_0$, we can show that $0 \leq c \cdot n^b \leq (n + a)^b$, and therefore $(n+a)^b$ = $\Omega(n^b)$. 
		\newline
		Since we have shown that $(n+a)^b$ is $O(n^b)$ and  $\Omega(n^b)$, $(n+a)^b$ = $\Theta(n^b)$.
		\newpage
		
		\item \textbf {\underline{Problem 5 Extra Credit:}} Show that for any non-negative integer $b$ and any negative integer $a$,
		$(n+a)^b = \Theta(n^b).$\newline
		Let $z$ = $-a$, so that $(n+a)^b = (n-z)^b$ 
		
		\textbf{\underline{Proof}}\newline
		\textbf{Case 1: $(n-z)^b$ = $O(n^b)$}. \newline
		If $f(n) = O(g(n))$, then $\exists c > 0$ $\exists n_0 > 0$ such that 
		$0 \leq f(n) \leq c \cdot g(n)$. Then $\dots$
		\begin{center}
		\centering{$\exists c > 0$ $\exists n_0 > 0$ such that 
			$0 \leq (n-z)^b \leq c \cdot n^b$.}
		\centering{\flushleft{$(n-z)^b \leq c \cdot n^b$}}
		\centering{\flushleft{$n-z \leq c^{1/b} \cdot n$}}
		\centering{\flushleft{$-z \leq c^{1/b} \cdot n - n$}}
		\centering{\flushleft{$-z \leq n(c^{1/b} - 1)$}}
		\centering{\flushleft{Let $c^{1/b} = 2$, therefore $c = 2^b$}}
		\centering{\flushleft{$-z \leq n (2 - 1)$}}
		\centering{\flushleft{$-z \leq n$}}
		\end{center}
		Choose $n_0 = |-z|$ and $c = 2^b$, so $0 \leq (n-z)^b \leq c \cdot n^b$. Thus $(n-z)^b$ = $O(n^b)$ so $(n+a)^b$ = $O(n^b)$ for any positive integer $b$ and any negative integer $a$.
		\newline\newline
		\textbf{Case 2: $(n-z)^b$ = $\Omega(n^b)$}. \newline
		If $f(n) = \Omega(g(n))$, then $\exists c > 0$ $\exists n_0 > 0$ such that 
		$0 \leq c \cdot g(n) \leq f(n)$. Then $\dots$
		\begin{center}
		\centering{$\exists c > 0$ $\exists n_0 > 0$ such that 
			$0 \leq c \cdot n^b \leq (n - z)^b$.}
		\centering{\flushleft{$c \cdot n^b \leq (n-z)^b$}}
		\centering{\flushleft{$c^{1/b} \cdot n \leq n-z$}}
		\centering{\flushleft{$z \leq n-c^{1/b} \cdot n$}}
		\centering{\flushleft{$z \leq n(1 -c^{1/b})$}}
		\centering{\flushleft{Let $c^{1/b} = \frac{1}{2}$, therefore $c = (\frac{1}{2})^b$}}
		\centering{\flushleft{$z \leq n(1 -\frac{1}{2})$ $\rightarrow$
		$z \leq \frac{n}{2}$ $\rightarrow$ $2z \leq n$}}
		\end{center}
		Choose $n_0 = 2z$ and $c = (\frac{1}{2})^b$, so $0 \leq c \cdot n^b \leq (n - z)^b$. Then $(n - z)^b = \Omega(n^b)$ so $(n+a)^b$ = $\Omega(n^b)$ for any positive integer $b$ and any negative integer $a$. \newline
		Since $(n-z)^b$ = $O(n^b)$ and $(n - z)^b = \Omega(n^b)$, $(n-z)^b = \Theta(n^b)$ $\iff$ $(n+a)^b$  $\Theta(n^b)$.
	\end{flushleft}
\end{document}